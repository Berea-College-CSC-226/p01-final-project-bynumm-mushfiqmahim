### T11: The Legend of Tuna: Breath of Catnip

### t11_game.py
######################################################################
# Author: Mekiyan, Mushfiq
# Username: BynumM, mushfiqmahim
#
# Assignment: T11: The Legend of Tuna: Breath of Catnip
#
# Purpose: Learn about classes, inheritance, and Pygame
######################################################################
# Acknowledgements:
#
# Inspired by Zelda, rebuilt into Python by: https://github.com/clear-code-projects/Zelda
# Art generated by Stable Diffusion: https://stablediffusionweb.com/app/image-generator
# Borrowed some ideas from: https://realpython.com/pygame-a-primer/

# licensed under a Creative Commons
# Attribution-Noncommercial-Share Alike 3.0 United States License.
###############################################################################
import pygame
from t11_NPC import NPC, Good_NPC, Bad_NPC
from t11_player import Player


class Game:
    def __init__(self):
        """Game class for handling the game logic."""
        pygame.init()
        self.size = (800, 600)
        self.screen = pygame.display.set_mode(self.size)
        pygame.display.set_caption("The Legend of Tuna: Playtime HUD")
        self.clock = pygame.time.Clock()
        self.bg_color = '#9CBEBA'
        self.text_color = (0, 0, 0)
        self.tuna = Player(self.size)
        self.tacocat = Good_NPC(self.size)
        self.whiskers = Bad_NPC(self.size)

        #PLAYTIME
        self.start_ticks = pygame.time.get_ticks()
        self.game_over = False
        self.final_elapsed_ms = None
        self.hud_font = pygame.font.SysFont("Consolas", 28)
        self.hud_pad = 10
        self.playtime_cache_text = ""
        self.playtime_cache_surf = None

    # Helper: format ms as MM:SS
    @staticmethod
    def format_mmss(ms: int) -> str:
        total_sec = ms // 1000
        mm = total_sec // 60
        ss = total_sec % 60
        return f"{mm:02d}:{ss:02d}"

    def current_elapsed_ms(self) -> int:
        if self.game_over and self.final_elapsed_ms is not None:
            return self.final_elapsed_ms
        return pygame.time.get_ticks() - self.start_ticks

    def draw_playtime_hud(self):
        """Draws elapsed playtime (MM:SS) top-right, erasing background first."""
        elapsed_ms = self.current_elapsed_ms()
        text = self.format_mmss(elapsed_ms)  # e.g., "01:23"
        if text != self.playtime_cache_text or self.playtime_cache_surf is None:
            self.playtime_cache_surf = self.hud_font.render(text, True, self.text_color)
            self.playtime_cache_text = text

        surf = self.playtime_cache_surf
        tw, th = surf.get_width(), surf.get_height()
        x = self.size[0] - tw - self.hud_pad
        y = self.hud_pad


        clear_rect = pygame.Rect(x - 4, y - 2, tw + 8, th + 4)
        pygame.draw.rect(self.screen, self.bg_color, clear_rect)

        # Draw the time
        self.screen.blit(surf, (x, y))

    def draw_end_message(self, msg: str):
        font = pygame.font.SysFont("ComicSans", 36)
        txt = font.render(msg, True, "darkblue")
        self.screen.blit(txt, (self.size[0] // 2 - txt.get_width() // 2,
                               self.size[1] - 100))

    def run(self):
        while True:
            # --- Events ---
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    return

            #Update
            if not self.game_over:
                self.tuna.movement(pygame.key.get_pressed())
                self.tacocat.movement()
                self.whiskers.movement()

                # Collision check
                if pygame.sprite.spritecollide(self.tuna, [self.tacocat], False):
                    # Freeze time on game over
                    self.final_elapsed_ms = self.current_elapsed_ms()
                    self.game_over = True
                    end_msg = f"You caught me!  Time: {self.format_mmss(self.final_elapsed_ms)}"
                elif pygame.sprite.spritecollide(self.tuna, [self.whiskers], False):
                    self.final_elapsed_ms = self.current_elapsed_ms()
                    self.game_over = True
                    end_msg = f"Caught by Whiskers :(  Time: {self.format_mmss(self.final_elapsed_ms)}"
                else:
                    end_msg = None
            else:
                end_msg = None

            # --- Draw ---
            self.screen.fill(self.bg_color)
            self.screen.blit(self.tuna.surf, self.tuna.rect)
            self.screen.blit(self.tacocat.surf, self.tacocat.rect)
            self.screen.blit(self.whiskers.surf, self.whiskers.rect)
            self.draw_playtime_hud()

            # If game_over, show the final message
            if self.game_over:
                if self.final_elapsed_ms is not None:
                    msg = f"Time: {self.format_mmss(self.final_elapsed_ms)}"
                else:
                    msg = "Time: 00:00"
                self.draw_end_message(msg)

            pygame.display.update()
            self.clock.tick(24)


def main():
    game = Game()
    game.run()


if __name__ == "__main__":
    main()
###################################################################### \
t11_NPC.py
######################################################################
# Author: Dr. Scott Heggen        TODO: Change this to your names
# Username: heggens               TODO: Change this to your usernames
#
# Assignment: T11: The Legend of Tuna: Breath of Catnip
#
# Purpose: Learn about classes, inheritance, and Pygame
######################################################################
# Acknowledgements:
#
# Inspired by Zelda, rebuilt into Python by: https://github.com/clear-code-projects/Zelda
# Art generated by Stable Diffusion: https://stablediffusionweb.com/app/image-generator
# Borrowed some ideas from: https://realpython.com/pygame-a-primer/

# licensed under a Creative Commons
# Attribution-Noncommercial-Share Alike 3.0 United States License.
#################################################################################### 
import pygame, random


class NPC(pygame.sprite.Sprite):
    move_distance = 10
    directions = ["north", "east", "south", "west"]

    def __init__(self, screen_size):
        """
        Represents the Good NPC in the game.

        :param screen_size: size of the window, for ensuring the NPC stays on screen
        """
        print("Spawning NPC")
        self.screen_size = screen_size
        super().__init__()
        self.surf = pygame.image.load('images/tacocat.png').convert_alpha()
        self.surf.set_colorkey((255, 255, 255), pygame.RLEACCEL)
        self.rect = self.surf.get_rect()
        self.rect.move_ip(self.screen_size[0]//4, self.screen_size[1]//4)
        self.path = random.choice(self.directions)
        self.position = [0,0]

    def get_direction(self):
        """
        Keeps the NPC on the screen.

        :return: None
        """
        if self.rect.bottom >= self.screen_size[1]:
            self.path = "north"
        if self.rect.top <= 0:
            self.path = "south"
        if self.rect.left <= 0:
            self.path = "east"
        if self.rect.right >= self.screen_size[0]:
            self.path = "west"
        elif random.random() > .95:
            self.path = random.choice(self.directions)

    def movement(self):
        """
        Moves the NPC around.

        :return: None
        """
        if self.path == "north":
            self.rect.move_ip(0, -self.move_distance)
            self.position[1] -= self.move_distance
        elif self.path == "south":
            self.rect.move_ip(0, self.move_distance)
            self.position[1] += self.move_distance
        if self.path == "east":
            self.rect.move_ip(self.move_distance, 0)
            self.position[0] -= self.move_distance
        if self.path == "west":
            self.rect.move_ip(-self.move_distance, 0)
            self.position[0] += self.move_distance

        self.get_direction()


class Good_NPC(NPC):
    def __init__(self, screen_size):
        super().__init__(screen_size)

class Bad_NPC(NPC):
    def __init__(self, screen_size):
        super().__init__(screen_size)
        self.surf = pygame.image.load('images/whiskers.png').convert_alpha()
        self.surf.set_colorkey((255, 255, 255), pygame.RLEACCEL)
        self.rect = self.surf.get_rect()
        self.rect.move_ip(self.screen_size[0] // 4, self.screen_size[1] // 4)
        self.current_N_S = "south"

    def get_direction(self):
        """
        Keeps the NPC on the screen.

        :return: None
        """
        if self.rect.bottom >= self.screen_size[1]:
            if self.rect.left <= self.screen_size[0]//2:
                self.path = "east"
            else:
                self.path = "west"
        if self.rect.top <= 0:
            if self.rect.left <= self.screen_size[0]//2:
                self.path = "east"
            else:
                self.path = "west"
        if self.rect.left <= 0 or self.rect.right >= self.screen_size[0]:
            self.path = self.current_N_S
        if self.rect.bottom >= self.screen_size[1]:
            self.current_N_S = "north"
            self.path = self.current_N_S
        elif self.rect.top <= 0:
            self.current_N_S = "south"
            self.path = self.current_N_S



    def movement(self):
        if self.path == "north":
            self.rect.move_ip(0, -self.move_distance)
            if random.random() > .55:
                if self.rect.left <= self.screen_size[0] // 2:
                    self.path = "east"
                else:
                    self.path = "west"
        elif self.path == "south":
            self.rect.move_ip(0, self.move_distance)
            if random.random() > .55:
                if self.rect.left <= self.screen_size[0] // 2:
                    self.path = "east"
                else:
                    self.path = "west"
        if self.path == "east":
            self.rect.move_ip(self.move_distance, 0)
        if self.path == "west":
            self.rect.move_ip(-self.move_distance, 0)

        self.get_direction()
###################################################################################
t11_players.py
######################################################################
# Author: Dr. Scott Heggen        TODO: Change this to your names
# Username: heggens               TODO: Change this to your usernames
#
# Assignment: T11: The Legend of Tuna: Breath of Catnip
#
#
# Purpose: Learn about classes, inheritance, and Pygame
######################################################################
# Acknowledgements:
#
# Inspired by Zelda, rebuilt into Python by: https://github.com/clear-code-projects/Zelda
# Art generated by Stable Diffusion: https://stablediffusionweb.com/app/image-generator
# Borrowed some ideas from: https://realpython.com/pygame-a-primer/

# licensed under a Creative Commons
# Attribution-Noncommercial-Share Alike 3.0 United States License.
####################################################################################
import pygame


class Player(pygame.sprite.Sprite):
    def __init__(self, screen_size):
        """
        Represents the player in the game.

        :param screen_size: Screen size, for keeping character on the screen
        """
        super().__init__()
        self.screen_size = screen_size
        print("Spawning player")
        self.surf = pygame.image.load('images/tuna.png').convert_alpha()
        self.surf.set_colorkey((255, 255, 255), pygame.RLEACCEL)
        self.rect = self.surf.get_rect()
        self.rect.move_ip(self.screen_size[0]//2, self.screen_size[1]//2)


    def movement(self, keys):
        """
        Handles up, down, left, right movement events from the user

        :param keys: key presses from pygame event listener

        :return: None
        """
        if keys[pygame.K_UP]:
            self.rect.move_ip(0, -3)
        elif keys[pygame.K_DOWN]:
            self.rect.move_ip(0, 3)
        if keys[pygame.K_RIGHT]:
            self.rect.move_ip(3, 0)
        elif keys[pygame.K_LEFT]:
            self.rect.move_ip(-3, 0)
####################################################################################
### T12: Events and GUIs
T12_dna_graphics.py
######################################################################
# Authors: Scott Heggen       TODO: Change this to your name
# Username: heggens           TODO: Change this to your username
#
# T12: Events and GUIs
#
# Purpose: Show interactive DNA strand copying using the turtle library.
#  This program also uses both mouse click and keypress event handling.
#  The mouse click causes the complementary nucleotides to appear under
#  the base that the user clicks on in the DNA strand.
# ######################################################################
# Acknowledgements:
#
# Original code written by Dr. Mario Nakazawa
# Previously modified by Scott Heggen and Brian Schack
#
# licensed under a Creative Commons
# Attribution-Noncommercial-Share Alike 3.0 United States License.
####################################################################################


import turtle, random


# Global variables which will be used throughout the program.
global nucleotides
nucleotides = {"A": "pink", "T": "green", "C": "magenta", "G": "yellow"}


global complement
complement = {"T": "A", "A": "T", "G": "C", "C": "G"}


global max_bases                # We'll be using this variable inside an event handler, so it needs global scope
max_bases = 4




def draw_scaffold():
   """
   Create the top and bottom scaffold for the nucleotides
   to be added afterwards.


   :return: None
   """


   dna_protein = turtle.Turtle()
   dna_protein.hideturtle()
   dna_protein.shape("square")
   dna_protein.penup()
   dna_protein.setpos(-260,230)
   dna_protein.pendown()
   dna_protein.pensize(20)
   dna_protein.forward(500)


   dna_protein.penup()
   dna_protein.setpos(-260,-42)
   dna_protein.pendown()
   dna_protein.pensize(20)
   dna_protein.forward(500)


   dna_protein.penup()
   dna_protein.setpos(0,-170)
   dna_protein.write("Click on the black square for each nucleotide \nin the DNA strand created at the top\nto get the complement in the strand at the bottom!\n\nPress 'q' to quit.", move=False,align='center',font=("Arial",15,("bold","normal")))




def draw_random_DNA(current_base_turtle, base_index, letter):
   """
   Draw a random sequence to be used later to create the complementary base pair.


   :param current_base_turtle: a turtle object
   :param base_index: an index, to help position the turtle
   :param letter: the letter being drawn
   :return: None
   """
   current_base_turtle.penup()
   current_base_turtle.right(90)
   current_base_turtle.setpos(-250 + 95*base_index, 230)       # Moves the turtle right the appropriate amount
   current_base_turtle.pendown()
   current_base_turtle.shape("square")
   current_base_turtle.pensize(10)
   current_base_turtle.forward(50)
   current_base_turtle.color(nucleotides[letter])
   current_base_turtle.pensize(30)
   current_base_turtle.forward(70)
   current_base_turtle.backward(40)
   current_base_turtle.color("black")


   # draw out the letters for the base_turtles and return back to the center.
   (xpos, ypos) = current_base_turtle.pos()
   letter_turtle.setpos(xpos, ypos+5 )
   letter_turtle.write(letter,move=False,align='center',font=("Arial",25,("bold","normal")))
   letter_turtle.setpos(0,0)




def draw_complement(letter, x, y):
       """
       Draws the complement strand for a given letter at the correct location.


       :param letter: the base letter
       :param x: the mouse x-coordinate
       :param y: the mouse y-coordinate
       :return: None
       """
       pair_turtle = turtle.Turtle()
       pair_turtle.hideturtle()
       pair_turtle.penup()
       pair_turtle.goto(x, y)
       pair_turtle.right(90)
       pair_turtle.forward(190)
       pair_turtle.pendown()
       pair_turtle.color("black")
       pair_turtle.pensize(10)
       pair_turtle.back(50)
       pair_turtle.color(nucleotides[complement[letter]])          # sets the color to the complement's color
       pair_turtle.pensize(30)


       (x_pos, y_pos) = pair_turtle.pos()


       pair_turtle.back(70)
       pair_turtle.penup()


       # draw the letter for that base
       letter_turtle.setpos(x_pos, y_pos - 10)
       letter_turtle.write(complement[letter], move=False, align='center', font=("Arial", 25, ("bold", "normal")))
       letter_turtle.setpos(0, 0)


       # Resets stuff
       pair_turtle.back(70)
       pair_turtle.showturtle()
       pair_turtle.color("black")




def base_handler(x, y):
   """
   Event handler for clicks on turtles.
   Draws the complement strand.
   Each turtle reuses this handler.


   :param x: x-coordinate of the mouse
   :param y: y-coordinate of the mouse
   :return: None
   """
   global current_letter
   global current_base


   draw_complement(current_letter, x, y)           # Draw the complement strand
   current_base += 1
   if current_base <= max_bases:
       # Repeat the program up to four times. Creates a new letter, new turtle, and reuses the click handler base_handler
       current_letter = random.choice(list(nucleotides.keys()))
       base_turtle = turtle.Turtle()
       draw_random_DNA(base_turtle, current_base, current_letter)
       base_turtle.onclick(base_handler)




def main():
   """
   Interactive DNA sequence drawing program.


   :return: None
   """
   global letter_turtle            # We'll be using this variable inside an event handler, so it needs global scope
   global current_base             # We'll be using this variable inside an event handler, so it needs global scope
   global current_letter           # We'll be using this variable inside an event handler, so it needs global scope


   letter_turtle = turtle.Turtle()
   letter_turtle.hideturtle()
   letter_turtle.penup()


   draw_scaffold()


   current_base = 1
   current_letter = random.choice(list(nucleotides.keys()))        # Picks a random letter from the dictionary keys
   base_turtle = turtle.Turtle()


   draw_random_DNA(base_turtle, current_base, current_letter)      # Draws a random DNA


   base_turtle.onclick(base_handler)       # Binds the first turtle to the base_handler event handler


   # It's not common, but sometimes useful to define functions within other functions.
   def quit_program():
       """
       Event handler for quitting the program


       :return: None
       """
       wn.bye()


   wn = turtle.Screen()
   wn.onkey(quit_program, "q")     # Binds to the quit_program event handler above
   wn.listen()                     # Needed to capture events
   wn.mainloop()                   # Keeps the program running




main()

t12_dna_graphics_without_classes.py

######################################################################
# Authors: Scott Heggen       TODO: Change this to your name
# Username: heggens           TODO: Change this to your username
#
# T12: Events and GUIs
#
# Purpose: Show interactive DNA strand copying using the turtle library.
#  This program also uses both mouse click and keypress event handling.
#  The mouse click causes the complementary nucleotides to appear under
#  the base that the user clicks on in the DNA strand.
# ######################################################################
# Acknowledgements:
#
# Original code written by Dr. Mario Nakazawa
# Previously modified by Scott Heggen and Brian Schack
#
# licensed under a Creative Commons
# Attribution-Noncommercial-Share Alike 3.0 United States License.
####################################################################################


import turtle
import random




class DNADraw:
   # Class variables which will be used throughout the program.
   nucleotides = {"A": "pink", "T": "green", "C": "magenta", "G": "yellow"}
   complement = {"T": "A", "A": "T", "G": "C", "C": "G"}
   max_bases = 4
  
   def __init__(self):
       self.letter_turtle = turtle.Turtle()
       self.letter_turtle.hideturtle()
       self.letter_turtle.penup()
  
       self.draw_scaffold()
  
       self.current_base = 1
       self.current_letter = random.choice(list(self.nucleotides.keys()))        # Picks a random letter from the dictionary keys
       self.base_turtle = turtle.Turtle()
  
       self.draw_random_DNA()      # Draws a random DNA
  
       self.base_turtle.onclick(self.base_handler)       # Binds the first turtle to the base_handler event handler


       self.wn = turtle.Screen()
       self.wn.onkey(self.quit_program, "q")     # Binds to the quit_program event handler above
       self.wn.listen()                          # Needed to capture events
       self.wn.mainloop()                        # Keeps the program running


   def quit_program(self):
           """
           Event handler for quitting the program.


           :return: None
           """
           self.wn.bye()


   def draw_scaffold(self):
       """
       Create the top and bottom scaffold for the nucleotides
       to be added afterwards.
  
       :return: None
       """


       dna_protein = turtle.Turtle()
       dna_protein.hideturtle()
       dna_protein.shape("square")
       dna_protein.penup()
       dna_protein.setpos(-260,230)
       dna_protein.pendown()
       dna_protein.pensize(20)
       dna_protein.forward(500)
  
       dna_protein.penup()
       dna_protein.setpos(-260,-42)
       dna_protein.pendown()
       dna_protein.pensize(20)
       dna_protein.forward(500)
  
       dna_protein.penup()
       dna_protein.setpos(0,-170)
       dna_protein.write("Click on the black square for each nucleotide \nin the DNA strand created at the top\nto get the complement in the strand at the bottom!\n\nPress 'q' to quit.", move=False,align='center',font=("Arial",15,("bold","normal")))


   def draw_random_DNA(self):
       """
       Draw a random sequence to be used later to create he complementary base pair


       :return: None
       """
       self.base_turtle.penup()
       self.base_turtle.right(90)
       self.base_turtle.setpos(-250 + 95 * self.current_base, 230)
       self.base_turtle.pendown()
       self.base_turtle.shape("square")
       self.base_turtle.pensize(10)
       self.base_turtle.forward(50)
       self.base_turtle.color(self.nucleotides[self.current_letter])
       self.base_turtle.pensize(30)
       self.base_turtle.forward(70)
       self.base_turtle.backward(40)
       self.base_turtle.color("black")
  
       # draw out the letters for the base_turtles and return back to the center.
       (xpos, ypos) = self.base_turtle.pos()
       self.letter_turtle.setpos(xpos, ypos+5)
       self.letter_turtle.write(self.current_letter, move=False, align='center',
                                font=("Arial", 25, ("bold", "normal")))
       self.letter_turtle.setpos(0,0)


   def draw_complement(self, x, y):
       """
       Draws the complement strand for a given letter at the correct location


       :param x: the mouse x-coordinate
       :param y: the mouse y-coordinate
       :return: None
       """
       pair_turtle = turtle.Turtle()
       pair_turtle.hideturtle()
       pair_turtle.penup()
       pair_turtle.goto(x, y)
       pair_turtle.right(90)
       pair_turtle.forward(190)
       pair_turtle.pendown()
       pair_turtle.color("black")
       pair_turtle.pensize(10)
       pair_turtle.back(50)
       # sets the color to the complement's color
       pair_turtle.color(self.nucleotides[self.complement[self.current_letter]])
       pair_turtle.pensize(30)


       (x_pos, y_pos) = pair_turtle.pos()


       pair_turtle.back(70)
       pair_turtle.penup()


       # draw the letter for that base
       self.letter_turtle.setpos(x_pos, y_pos - 10)
       self.letter_turtle.write(self.complement[self.current_letter], move=False, align='center',
                                font=("Arial", 25, ("bold", "normal")))
       self.letter_turtle.setpos(0, 0)


       # Resets stuff
       pair_turtle.back(70)
       pair_turtle.showturtle()
       pair_turtle.color("black")


   def base_handler(self, x, y):
       """
       Event handler for clicks on turtles.
       Draws the complement strand.
       Each turtle reuses this handler.
  
       :param x: x-coordinate of the mouse
       :param y: y-coordinate of the mouse
       :return: None
       """


       self.draw_complement(x, y)           # Draw the complement strand
       self.current_base += 1
       if self.current_base <= self.max_bases:
           # Repeat the program up to 4x. Creates a new letter, new turtle, and reuses the click handler base_handler
           self.current_letter = random.choice(list(self.nucleotides.keys()))
           self.base_turtle = turtle.Turtle()
           # A better solution here uses a collaboration with a Nucleotide object and spawns new ones,
           # eliminating the issue from the Google Doc with every nucleotide being clickable.
           self.draw_random_DNA()
           self.base_turtle.onclick(self.base_handler)




def main():
   """
   Interactive DNA sequence drawing program.


   :return: None
   """


   dna = DNADraw()     # Yup. that's it!
   # DNADraw()           # Technically, this would work also. Why?




main()

T12_onkey_example.py 

import turtle


# The next four functions are our "event handlers".
def h1():
   tess.forward(30)


def h2():
   tess.left(45)


def h3():
   tess.right(45)


def h4():
   wn.bye()                        # Close down the turtle window


def main():
   global wn
   global tess


   wn = turtle.Screen()                 # Get a reference to the window
   wn.setup(400,500)                    # Determine the window size
   wn.title("Handling keypresses!")     # Change the window title
   wn.bgcolor("lightgreen")             # Set the background color


   tess = turtle.Turtle()               # Create our favorite turtle


   # These lines "wire up" keypresses to the handlers we've defined.
   wn.onkey(h1, "Up")
   wn.onkey(h2, "Left")
   wn.onkey(h3, "Right")
   wn.onkey(h4, "q")


   # Now we need to tell the window to start listening for events,
   # If any of the keys that we're monitoring is pressed, its
   # handler will be called.
   wn.listen()


   wn.mainloop()


main()

T12_onkey_example_with_classes.py

######################################################################
# Author: Scott Heggen     TODO: Change this to your name
# Username: heggens        TODO: Change this to your username
#
# T12: Events and GUIs
#
# Purpose: To demonstrate how turtle object responds to key press events.
#   the up arrow would move the turtle forward
#   the right arrow would turn the turtle right by 45 degrees
#   the left arrow would turn the turtle left by 45 degrees
#   the "q" key would quit the application
# ######################################################################
# Acknowledgements:
#
#   This code is adapted from http://openbookproject.net/thinkcs/python/english3e/events.html#mouse-events
#   by Dr. Mario Nakazawa
#
# licensed under a Creative Commons
# Attribution-Noncommercial-Share Alike 3.0 United States License.
####################################################################################


import turtle


class DrivenTurtle:
   def __init__(self):
       self.wn = turtle.Screen()      # Get a reference to the window
       self.turt = turtle.Turtle()    # Create our favorite turtle


       self.wn.setup(400, 500)  # Determine the window size
       self.wn.title("Handling keypresses!")  # Change the window title
       self.wn.bgcolor("lightgreen")  # Set the background color


       # These lines "wire up" keypresses to the handlers we've defined.
       self.wn.onkey(self.h1, "Up")
       self.wn.onkey(self.h2, "Left")
       self.wn.onkey(self.h3, "Right")
       self.wn.onkey(self.h4, "q")


       # Now we need to tell the window to start listening for events,
       # If any of the keys that we're monitoring is pressed, its
       # handler will be called.
       self.wn.listen()
       self.wn.mainloop()


   def h1(self):
       self.turt.forward(30)


   def h2(self):
       self.turt.left(45)


   def h3(self):
       self.turt.right(45)


   def h4(self):
       self.wn.bye()                        # Close down the turtle window


def main():
   h = DrivenTurtle()  # Make an instance of the class DrivenTurtle


main()

T12_tkinter.py

######################################################################
# Author: Scott Heggen     TODO: Change this to your name
# Username: heggens        TODO: Change this to your username
#
# T12: Events and GUIs
#
# Purpose: To explore the Tkinter module for making a GUI
#
# A GUI widget is a graphical component such as a button, text label as shown below.
# GUI widgets also exist to make drop-down menus and scroll bars, display images, etc...
# Tkinter gives you the ability to create GUI Windows containing widgets.
# This program is a simple exploration.
#######################################################################
# Acknowledgements:
#
# Original code written by Dr. Jan Pearce, modified by Dr. Scott Heggen
#
# licensed under a Creative Commons
# Attribution-Noncommercial-Share Alike 3.0 United States License.
####################################################################################


import tkinter as tk       # Python's most commonly used GUI package.




class MyTkinterApp:
   def __init__(self, windowtext="Exploring Tkinter"):
       """
       The initializer creates a window to contain the widgets


       :param windowtext: The text at the top of the window title
       """
       self.root = tk.Tk()                         # Create the root window where all widgets go
       self.root.minsize(width=250, height=100)    # Sets the window's minimum size
       self.root.maxsize(width=250, height=100)    # Sets the window's maximum size
       self.root.title(windowtext)                 # Sets root window title


       self.count = 0                              # Click counter for myButton1
       # self.myButton1 = None
       # self.myTextLabel1 = None
       self.create_GUI()


   def create_GUI(self):
       # Note that when myButton1 button is pushed, self.button1handler is called
       self.myButton1 = tk.Button(self.root, text="What is your name?", command=self.button1_handler)
       self.myButton1.pack()                       # pack means add to window


       self.myTextBox1 = tk.Entry(self.root)
       self.myTextBox1.pack()


       self.myTextLabel1Text = tk.StringVar()      # Makes a Tkinter string variable
       self.myTextLabel1Text.set("")               # Sets the Tkinter string variable
       self.myTextLabel1 = tk.Label(self.root, textvariable=self.myTextLabel1Text)
       self.myTextLabel1.pack()


   def button1_handler(self):
       """
       Event handler for myButton1 above.
       Gets the text from the textbox and writes in myTextLabel1


       :return: None
       """
       txt = self.myTextBox1.get()                 # Retrieves the text entered by the user
       self.count += 1                             # increments each time the handler is called (button is pressed)
       if self.count % 10 == 0:
           message = "Wow, {1} clicks! Keep it up, {0}!".format(txt, self.count)
       else:
           message = "Hey {0}, click it again!\nYou have clicked the button {1} times.".format(txt, self.count)
       self.myTextLabel1Text.set(message)


def main():
   """
   Creates GUI and uses button, textbox and label GUI widgets


   :return: None
   """


   gooey = MyTkinterApp("CSC226 Hello GUI")           # Create a new myTkinter object
   gooey.root.mainloop()                           # Needed to start the event loop


if __name__ == "__main__":
   main()

T12_turtle_interactive.py

######################################################################
# Author: Scott Heggen     TODO: Change this to your name
# Username: heggens        TODO: Change this to your username
#
# T12: Events and GUIs
#
# Purpose: To demonstrate how turtle object responds to mouse click events.
# ######################################################################
# Acknowledgements:
#
#   This code is adapted from:
#   http://openbookproject.net/thinkcs/python/english3e/events.html#mouse-events
#   by Dr. Mario Nakazawa
#
# licensed under a Creative Commons
# Attribution-Noncommercial-Share Alike 3.0 United States License.
####################################################################################


import turtle




def h1(x, y):
   """
   Event handler for mouse click events


   :param x: x coordinate of the mouse on the screen
   :param y: y coordinate of the mouse on the screen
   :return: None
   """
   tess.goto(x, y)




def main():
   """
   Simple program for demonstrating mouse click events


   :return: None
   """
   global tess
   tess = turtle.Turtle()


   wn = turtle.Screen()
   wn.setup(400,500)
   wn.title("How to handle mouse clicks on the window!")
   wn.bgcolor("lightgreen")


   tess.color("purple")
   tess.pensize(3)
   tess.shape("circle")


   # NOTICE that the screen is responding to the click events!
   wn.onclick(h1)      # Wire up a click handler to the window.


   wn.mainloop()




main()

T12_turtle_interactive_with_class.py

######################################################################
# Author: Scott Heggen     TODO: Change this to your name
# Username: heggens        TODO: Change this to your username
#
# T12: Events and GUIs
#
# Purpose: To demonstrate how turtle object responds to mouse click events.
# ######################################################################
# Acknowledgements:
#
#   This code is adapted from http://openbookproject.net/thinkcs/python/english3e/events.html#mouse-events
#   by Dr. Scott Heggen
#
# licensed under a Creative Commons
# Attribution-Noncommercial-Share Alike 3.0 United States License.
####################################################################################


import turtle


class ClickyTurtle:
   def __init__(self):
       self.wn = turtle.Screen()
       self.wn.setup(400,500)
       self.wn.title("How to handle mouse clicks on the window!")
       self.wn.bgcolor("lightgreen")
       self.tess = turtle.Turtle()
       self.tess.color("purple")
       self.tess.pensize(3)
       self.tess.shape("circle")


       # NOTICE that the screen is responding to the click events!
       self.wn.onclick(self.h1)      # Wire up a click handler to the window.


       self.wn.mainloop()


   def h1(self, x, y):
       self.tess.goto(x, y)


def main():
   c = ClickyTurtle()


main()
#####################################################################################################
T10: Intro to Classes
#####################################################################################################
######################################################################
# Author: Dr. Scott Heggen         TODO: Change this to your names
# Username: heggens                TODO: Change this to your usernames
#
# Assignment: T10: Intro to Classes
#
# Purpose:  Demonstrate the collaboration between classes,
#           such as using a point to create a rectangle
######################################################################
# Acknowledgements:
#
# Original code created by Dr. Scott Heggen


# licensed under a Creative Commons
# Attribution-Noncommercial-Share Alike 3.0 United States License.
####################################################################################


import t10_rectangle as rectangle  # notice the different ways we can import, and how that changes how we use it below
from t10_point import Point        # and again...
import random
import turtle


def generate_random_colors(n, rng):
   """
   Generates mulitle random numbers at once


   return: tuple of n random numbers
   """
   rans = []
   for i in range(n):
       new_random = random.randrange(rng)
       rans.append(new_random)


   return tuple(rans)


def main():
   """
   Draws 25 randomly placed, randomly sized, randomly colored rectangles using the turtle library.
   The code demonstrates interactions between classes, such as the use of a Point
   object to create a Rectangle object.


   :return: None
   """
   wn = turtle.Screen()
   wn.colormode(255)


   for i in range(25):
       # each loop iteration, a new point object at a random (x, y) coordinate
       (randx, randy) = generate_random_colors(2, 500)
       pt = Point(randx-250, randy-250)


       # a rectangle object which starts at the point defined above
       (randw, randh) = generate_random_colors(2, i + 100)
       rect = rectangle.Rectangle(pt, randw, randh)


       # calls the draw_rectangle method of the Rectangle object
       (randr, randg, randb) = generate_random_colors(3, 255)
       randa = random.randrange(360)
       rect.draw_rectangle(randr, randg, randb, randa)


   wn.exitonclick()




if __name__ == "__main__":
   main()

########################################################################
######################################################################
# Author: Mushfiq, Scott
# Username: mushfiqmahim, kirkpatrickm
#
# Assignment: T10: Intro to Classes
#
#
# Purpose: A class for creating rectangles. Collaborates with the Points class
######################################################################
# Acknowledgements:
####################################################################################




import turtle
from t10_point import Point
from t10_shape import Shape




def draw_sun(center: Point, radius_side: int, sides: int = 30) -> None:
   """
   Draws a 'sun' by approximating a circle with a many-sided regular polygon.


   :param center: Point where the sun starts (lower-left corner of polygon path)
   :param radius_side: side length for the polygon (controls size)
   :param sides: number of sides for the polygon (more sides ≈ rounder)
   :return: None
   """
   sun = Shape(center, sides, radius_side)
   sun.draw_shape(255, 215, 0)  # golden yellow




def draw_house(base_origin: Point, wall_size: int) -> None:
   """
   Draws a simple house: a square wall and a triangular roof.


   :param base_origin: lower-left corner of the house walls
   :param wall_size: side length of the square walls
   :return: None
   """
   # Walls (square)
   walls = Shape(base_origin, 4, wall_size)
   walls.draw_shape(205, 133, 63)  # brownish


   # Roof sits on top-left corner of walls
   roof_start = Point(base_origin.x, base_origin.y + wall_size)
   roof = Shape(roof_start, 3, wall_size)
   roof.draw_shape(178, 34, 34)  # brick red




def draw_pentagon_flower(center: Point, size: int) -> None:
   """
   Draws a decorative pentagon 'flower' near the house.


   :param center: starting point for the pentagon
   :param size: side length of the pentagon
   :return: None
   """
   p1 = Shape(center, 5, size)
   p1.draw_shape(138, 43, 226)  # blue-violet




def main() -> None:
   """
   Sets up the Turtle screen and draws multiple shapes of different sizes,
   using the Shape class. Exits on click.
   """
   wn = turtle.Screen()
   wn.title("T10 – My Shapes")
   wn.colormode(255)




   turtle.tracer(0, 0)




   # Sun (top-left)
   draw_sun(center=Point(-260, 160), radius_side=14, sides=30)


   # House (center-bottom)
   draw_house(base_origin=Point(-80, -150), wall_size=160)




   # Small triangle (path/stone)
   small_tri = Shape(Point(120, -160), 3, 50)
   small_tri.draw_shape(70, 130, 180)


   # Medium square (window)
   window = Shape(Point(-30, -60), 4, 40)
   window.draw_shape(173, 216, 230)  # light blue


   # Pentagon flower
   draw_pentagon_flower(center=Point(200, -40), size=70)


   # Another small polygon (bush)
   bush = Shape(Point(-180, -140), 6, 22)  # hexagon
   bush.draw_shape(34, 139, 34)




   wn.update()
   wn.exitonclick()




if __name__ == "__main__":
   main()
#########################################################################
######################################################################
# Author: Dr. Scott Heggen        TODO: Change this to your names
# Username: heggens               TODO: Change this to your usernames
#
# Assignment: T10: Intro to Classes
#
# Purpose:  Demonstrates a Point class and a related main() to create objects
######################################################################
# Acknowledgements:
#
# Based on the point class from our textbook:
# https://runestone.academy/ns/books/published/csc226-spr22/ClassesBasics/UserDefinedClasses.html




# licensed under a Creative Commons
# Attribution-Noncommercial-Share Alike 3.0 United States License.
####################################################################################


import turtle       # needed by both point class and main()
import random       # needed by main()




class Point:
   """
   The Point class represents and manipulates x,y coordinates.
   It is dependent upon the turtle libraries for draw_point() method.
   In particular, a Screen must exist and the color mode should be set to 255
   """
   max_size = 10


   def __init__(self, x=0, y=0):       # Each Point object has its own x and y coordinates and possibly a turtle
       """
       Initializer method a.k.a. Constructor:
       Creates a new point at x, y. If no x, y are given, the point is created at 0, 0


       :param x: the x coordinate of the point
       :param y: the y coordinate of the point
       """
       self.x = x
       self.y = y
       self.turtley = None


   def __str__(self):
       """
       Makes the str() function work with Points


       :return: A formatted string for better printing
       """
       return "({0}, {1})".format(self.x, self.y)


   def distance_from_origin(self):
       """
       Compute my distance from the origin


       :return: float representing distance from (0, 0)
       """
       return ((self.x ** 2) + (self.y ** 2)) ** 0.5


   def user_set(self):
       """
       Allows the user to change the x and y value of a Point


       :return: None
       """
       self.x = int(input("Enter x: "))
       self.y = int(input("Enter y: "))


   def draw_point(self, r=0, g=0, b=0, text=""):         # black is the default color
       """
       Instantiates a Turtle object and draws the Point on the Screen


       :param r: the red channel
       :param g: the green channel
       :param b: the blue channel
       :param text: any additional text to stamp
       :return: None
       """
       if not self.turtley:
           self.turtley = turtle.Turtle()
           self.turtley.hideturtle()
       self.turtley.color(r, g, b)
       self.turtley.penup()
       self.turtley.goto(self.x, self.y)
       self.turtley.showturtle()
       self.turtley.stamp()


       # This code was added from the original point.py class
       # to allow custom text to be written to the screen
       self.turtley.penup()
       if text == "":
           self.turtley.write(str(self), True)
       else:
           self.turtley.write(text, True)
       self.turtley.hideturtle()




   def getX(self):
       return self.x
   def getY(self):
       return self.y


   def midpoint(self,target):
       mx = (self.x + target.x) / 2
       my = (self.y + target.y) / 2
       return Point(mx, my)




# end class




def main():
   """
   A program that demonstrates the use of the Point class


   :return: None
   """
   wn = turtle.Screen()
   wn.colormode(255)        # change color modes


   p = Point()              # Instantiate an object of type Point at (0, 0)


   print(p.getX())
   print(p.getY())
   print("point = " + str(p))


   q = Point(30, 40)        # Make a second point at (30, 40)
   print("point = " + str(q))
   print("Check the turtle screen window to see your point")


   p.draw_point()           # draw Point p as the default color of black
   q.draw_point(255, 0, 0)# draw Point q as red (255, 0, 0)
   mp = q.midpoint(p)
   print(mp)


   print("\nPlease enter x and y values. To end, enter x = 0 and y = 0.")
   while q.x != 0 or q.y != 0:
       q.user_set()
       print("point = " + str(q))
       q.draw_point(random.randrange(256), random.randrange(256), random.randrange(256))  # Random color


   print("Exiting. Bye!")
   wn.bye()


# end main




if __name__ == "__main__":
   main()
#########################################################################

######################################################################
# Author: Dr. Scott Heggen        TODO: Change this to your names
# Username: heggens               TODO: Change this to your usernames
#
# Assignment: T10: Intro to Classes
#
#
# Purpose: A class for creating rectangles. Collaborates with the Points class
######################################################################
# Acknowledgements:
#
# Much of the code is originally from: http://openbookproject.net/thinkcs/python/english3e/


# licensed under a Creative Commons
# Attribution-Noncommercial-Share Alike 3.0 United States License.
####################################################################################


import turtle




class Rectangle:
   def __init__(self, posn, w, h):
       """
        A class to manufacture rectangle objects.


       :param posn: a Point object representing the starting point of the rectangle
       :param w: the rectangle width
       :param h: the rectangle height
       """
       self.corner = posn          # A Point object to hold the bottom left corner of the rectangle
       self.width = w
       self.height = h


   def __str__(self):
       """
       Overridden string class. Prints a rectangle object more cleanly


       :return: A formatted string
       """


       return "({0}, {1}, {2})".format(self.corner, self.width, self.height)


   def grow(self, delta_width, delta_height):
       """
       Grow (or shrink) this object by the deltas


       :param delta_width: change in the width
       :param delta_height: change in the height
       :return: None
       """
       self.width += delta_width
       self.height += delta_height


   def move(self, dx, dy):
       """
       Move this object by the deltas.


       :param dx: change in the x coordinate
       :param dy: change in the y coordinate
       :return: None
       """
       self.corner.x += dx
       self.corner.y += dy


   def draw_rectangle(self, r=0, g=0, b=0, angle=0, text=""):  # black is the default color
       """
       Instantiates a Turtle object and draws the Rectangle on the Screen at an angle, and tags it with a text.
       Notice the turtle is implemented differently here than in the Point class,
       as a demonstration of the many ways in which we can implement the same thing.


       :param r: the red channel
       :param g: the green channel
       :param b: the blue channel
       :param angle: the angle to draw the turtle
       :param text: any additional text to write
       :return: None
       """
       turt = turtle.Turtle()
       turt.color(r, g, b)
       turt.penup()


       # self.corner refers to a Point object, so self.corner.x refers to the x-coordinate;
       # self.corner.y refers to the y-coordinate
       turt.goto(self.corner.x, self.corner.y)


       # rotates to turtle by angle degrees
       turt.left(angle)
       turt.showturtle()
       turt.pendown()


       # draws the rectangle to the screen
       for i in range(2):
           turt.forward(self.width)
           turt.left(90)
           turt.forward(self.height)
           turt.left(90)


       # writes custom text to the screen if provided;
       # else prints the starting coordinates, width, and height of the rectangle
       if text == "":
           turt.write(str(self), True)
       else:
           turt.write(text, True)
       turt.hideturtle()
# end class


# Look. No main!

########################################################################
import turtle
import math
from t10_point import Point




class Shape:
   # Class attribute
   max_size = 500


   def __init__(self, start_point, num_sides, side_length):
       """
       Creates a new Shape object.


       :param start_point: Point object where the shape starts
       :param num_sides: number of sides of the shape (e.g., 3 for triangle, 4 for square)
       :param side_length: length of each side
       """
       self.start_point = start_point
       self.num_sides = num_sides
       self.side_length = side_length
       self.turtley = None  # Will be assigned in draw_shape()


   def draw_shape(self, r=0, g=0, b=0):
       """
       Draws the shape using turtle graphics.


       :param r, g, b: Color values for the shape (0–255)
       """
       # Set up turtle
       self.turtley = turtle.Turtle()
       self.turtley.hideturtle()
       self.turtley.speed(0)  # Fastest drawing
       turtle.colormode(255)
       self.turtley.color(r, g, b)


       # Go to the start point
       self.turtley.penup()
       self.turtley.goto(self.start_point.x, self.start_point.y)
       self.turtley.pendown()


       # Exterior angle formula
       turn_angle = 360 / self.num_sides


       # Draw the polygon
       for _ in range(self.num_sides):
           self.turtley.forward(self.side_length)
           self.turtley.left(turn_angle)
############################################################################################################